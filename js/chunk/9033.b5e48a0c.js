"use strict";(self.webpackChunkbalm_ui=self.webpackChunkbalm_ui||[]).push([[9033],{49033:function(e,t,a){a.d(t,{Z:function(){return p}});var n=a(73114),l=a(76580),d=a(8727),c=a(5522);const s={key:0,class:"mdc-tree-node__indent"},o={class:"mdc-tree-node__icon"},r=["onClick"],i=["onClick"],h=["onClick"],u={name:"UiTreeNode",customOptions:{UI_GLOBAL:c.Z}};var p=Object.assign(u,{props:{children:{type:Array,default:()=>[]},treeData:{type:Object,default:()=>({})}},setup(e){const t=e,a=t.treeData.dataFormat;function u(e){e.disabled||l.w.onCheck(t.treeData,e)}function p(e){const{children:t,...n}=e;return e[a.isLeaf]?e:n}return(k,f)=>{const m=(0,n.resolveComponent)("ui-tree-node");return(0,n.openBlock)(),(0,n.createElementBlock)("ul",null,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(e.children,((f,g)=>((0,n.openBlock)(),(0,n.createElementBlock)("li",{key:g,class:(0,n.normalizeClass)(["mdc-tree-node",{"mdc-tree-node--root":f.isRoot,"mdc-tree-node--leaf":f.isLeaf}])},[(0,n.createElementVNode)("div",{class:(0,n.normalizeClass)(["mdc-tree-node__content",{"mdc-tree-node--selected":f.selected||f.checked}])},[(0,n.renderSlot)(k.$slots,"before",{data:p(f)}),f.level?((0,n.openBlock)(),(0,n.createElementBlock)("div",s,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(f.level,(e=>((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:e,class:"mdc-tree-node__indent-unit"})))),128))])):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("div",o,[f[(0,n.unref)(a).isLeaf]?(0,n.createCommentVNode)("",!0):((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:0,onClick:e=>{return a=f,void l.w.onExpand(t.treeData,a);var a}},[f.expanded?(0,n.renderSlot)(k.$slots,"expand-more-icon",{key:0},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(c.Z).cssClasses.icon),"aria-hidden":"true"}," expand_more ",2)])):(0,n.renderSlot)(k.$slots,"expand-less-icon",{key:1},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(c.Z).cssClasses.icon),"aria-hidden":"true"}," chevron_right ",2)]))],8,r))]),e.treeData.multiple?((0,n.openBlock)(),(0,n.createElementBlock)("div",{key:1,class:"mdc-tree-node__checkbox",onClick:e=>u(f)},[f[(0,n.unref)(a).isLeaf]?((0,n.openBlock)(),(0,n.createBlock)(d.Z,{key:0,checked:f.checked,disabled:f.disabled},null,8,["checked","disabled"])):((0,n.openBlock)(),(0,n.createBlock)(d.Z,{key:1,checked:f.checked,indeterminate:f.indeterminate,disabled:f.disabled},null,8,["checked","indeterminate","disabled"]))],8,i)):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("label",{class:"mdc-tree-node__label",onClick:(0,n.withModifiers)((a=>{return e.treeData.multiple?u(f):(n=f,void l.w.onSelect(t.treeData,n));var n}),["self","prevent"])},[(0,n.renderSlot)(k.$slots,"title",{data:p(f)},(()=>[(0,n.createTextVNode)((0,n.toDisplayString)(f[(0,n.unref)(a).label]),1)]))],8,h),(0,n.renderSlot)(k.$slots,"after",{data:p(f)})],2),!f[(0,n.unref)(a).isLeaf]&&f.expanded?((0,n.openBlock)(),(0,n.createBlock)(m,{key:0,class:"mdc-tree-node__children",children:f[(0,n.unref)(a).children],"tree-data":e.treeData},(0,n.createSlots)({_:2},[(0,n.renderList)(k.$slots,((e,t)=>({name:t,fn:(0,n.withCtx)((e=>[(0,n.renderSlot)(k.$slots,t,(0,n.normalizeProps)((0,n.guardReactiveProps)(e)))]))})))]),1032,["children","tree-data"])):(0,n.createCommentVNode)("",!0)],2)))),128))])}}})},76580:function(e,t,a){a.d(t,{w:function(){return c}});const n=(e,t,a)=>{let{selectedValue:n,nodeMap:l,dataFormat:d}=e,{level:c,parentKey:s}=a,o=Object.assign({},t);const{value:r,children:i,hasChildren:h,isLeaf:u,disabled:p}=d,k=o[r],f=o[i],m=((e,t,a)=>e[t]||!a)(o,u,o[h]||f);return o.level=c,o.isRoot=!c,o.isLeaf=m,o.expanded=!1,o.selected=!Array.isArray(n)&&k===n,o.checked=Array.isArray(n)&&n.includes(k),o.parentKey=s,o.disabled=o[p],f||(o[i]=[]),m||(o.indeterminate=!1),l.has(k)||l.set(k,o),o};let l=[],d=[];class c{constructor(e){this.treeData=e}getData(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";const{dataFormat:l,maxLevel:d}=this.treeData,c=[],{value:s,children:o,hasChildren:r}=l;for(let i=0,h=e.length;i<h;i++){let l=n(this.treeData,e[i],{level:t,parentKey:a});const h=l[o],u=l[r]||h;t<d&&u&&(l[o]=this.getData(h,t+1,l[s])),c.push(l)}return c}static addData(e,t,a){const{dataFormat:l,nodeMap:d}=e,c=[],{value:s,children:o}=l,r=t.level+1,i=t[s];for(let h=0,u=a.length;h<u;h++){let t=n(e,a[h],{level:r,parentKey:i});t.checked&&this.setMultipleSelectedValue(e,t[s],!0),c.push(t)}t[o]=c,t.expanded=!0,d.set(i,t)}static async onExpand(e,t){if(e.loadData){const{dataFormat:a}=e;if(t[a.children]&&t[a.children].length)t.expanded=!t.expanded;else{let n=await e.loadData(t[a.value]);Array.isArray(n)?this.addData(e,t,n):console.warn("[UiTree]","Invalid data")}}else t.expanded=!t.expanded}static async collapseAllNode(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);d.expanded=!1,d.children&&d.children.length&&this.collapseAllNode(e,d.children)}return!0}static setSingleSelectedValue(e,t,a){const{nodeMap:n}=e,l=n.get(t);l&&(l.selected=a,e.selectedEvent={selected:a,selectedNodes:t,node:l})}static onSelect(e,t){const{dataFormat:a,selectedValue:n}=e,l=t[a.value];n&&this.setSingleSelectedValue(e,n,!1),e.selectedValue=l,this.setSingleSelectedValue(e,l,!0)}static setMultipleSelectedValue(e,t,a){const{dataFormat:n,nodeMap:l,filterParentNode:d}=e,c=l.get(t);a&&!c.indeterminate?e.selectedValue.includes(t)||(d?c.isLeaf&&e.selectedValue.push(t):e.selectedValue.push(t)):e.selectedValue=e.selectedValue.filter((e=>e!==t))}static setChildrenCheckedValue(e,t,a){const{dataFormat:n,nodeMap:d}=e,{value:c,children:s}=n;for(let o=0,r=t.length;o<r;o++){let n=Object.assign({},t[o]);const r=n[c],i=n[s],h=d.get(r);h&&(a?!h.checked&&l.push(r):h.checked&&l.push(r),h.indeterminate=!1,h.checked=a,this.setMultipleSelectedValue(e,r,a)),!n.isLeaf&&i.length&&this.setChildrenCheckedValue(e,i,a)}}static setParentCheckedValue(e,t){const{dataFormat:a,nodeMap:n}=e,{value:d,children:c}=a;if(t){const a=t[d],s=t[c],o=s.filter((e=>e.checked||e.indeterminate)),r=n.get(a);if(o.length){const t=o.filter((e=>e.checked)).length,n=t===s.length;n?!r.checked&&l.push(a):r.checked&&l.push(a),r.checked=n,r.indeterminate=!n,this.setMultipleSelectedValue(e,a,n)}else r.checked=!1,r.indeterminate=!1;t.isRoot||this.setParentCheckedValue(e,n.get(t.parentKey))}}static onCheck(e,t){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=!t.checked;"boolean"===typeof a&&(n=a);const{dataFormat:d,nodeMap:c,singleChecked:s}=e,{value:o,children:r}=d,i=t[o],h=t[r];s?(t.checked=n,this.setMultipleSelectedValue(e,i,n),e.selectedEvent={checked:n,checkedNodes:[i],node:t}):(l=[i],t.isLeaf?(t.checked=n,this.setMultipleSelectedValue(e,i,n)):(t.indeterminate&&(t.indeterminate=!1,n=!0),t.checked=n,this.setMultipleSelectedValue(e,i,n),this.setChildrenCheckedValue(e,h,n)),t.isRoot||this.setParentCheckedValue(e,c.get(t.parentKey)),e.selectedEvent={checked:n,checkedNodes:l,node:t})}static async handleExpandKeys(e,t,a){const{dataFormat:n,nodeMap:l}=e;for await(let d of t){const t=d[n.value],c=l.get(t);a.includes(t)&&this.onExpand(e,c),d.children&&d.children.length&&this.handleExpandKeys(e,d.children,a)}}static async handleExpandAll(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);this.onExpand(e,d),d.children&&d.children.length&&this.handleExpandAll(e,d.children)}}static async findTreeNode(e,t,a){if(e[t]===a)return e;if(e.children&&e.children.length)for(let n=0;n<e.children.length;n++){const l=await this.findTreeNode(e.children[n],t,a);if(null!==l)return l}return null}static toReverseArray(e){const t=[];for(let a=e.length-1;a>=0;a--)t.push(e[a]);return t}static async handleAutoExpandSelected(e,t,a,n){if(await this.collapseAllNode(n,e)){const l=await this.findTreeNode(e[0],t,a);if(d.push(l[t]),l.parentKey&&this.handleAutoExpandSelected(e,t,l.parentKey,n),!l.parentKey){const t=this.toReverseArray(d);n&&this.handleExpandKeys(n,e,t)}}}static async setExpanded(e,t,a){let{autoExpandParent:n,defaultExpandedKeys:l,autoExpandAll:d}=a;const{dataFormat:c,nodeMap:s}=e;if(d&&this.handleExpandAll(e,t),n)if(l.length)this.handleExpandKeys(e,t,l);else for await(let o of t){const t=o[c.value],a=s.get(t);this.onExpand(e,a)}}static resetSelected(e,t){const{nodeMap:a}=e;for(let n=0,l=t.length;n<l;n++){const l=t[n],d=a.get(l);d&&this.onCheck(e,d,!1)}}static setSelected(e,t,a){let{nodeList:n,autoExpandSelected:l}=a;const{dataFormat:c,nodeMap:s,multiple:o}=e,r=Array.isArray(t)?t:[t];for(let d=0,i=r.length;d<i;d++){const t=r[d],a=s.get(t);a&&(o?this.onCheck(e,a,!0):this.onSelect(e,a))}l&&!Array.isArray(t)&&(d=[],this.handleAutoExpandSelected(n,c.value,t,e))}static async createNode(e,t,a){const{dataFormat:l,nodeMap:d}=e,{value:c,children:s,hasChildren:o}=l,r=d.get(t),i=a[c];let h=n(e,a,{level:r.level+1,parentKey:t,checked:!1});r.isLeaf?(r[s].unshift(h),r[o]||(r[o]=!0),r.isLeaf=!1):r[o]?r[s].length?r[s].unshift(h):await this.onExpand(e,r):(r[s].unshift(h),r[o]=!0,r.expanded=!0),d.set(t,r),d.set(i,h)}static updateNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:c}=n,s=a[d],o=l.get(s);Object.keys(o).forEach((e=>{"undefined"!==typeof a[e]&&(o[e]=a[e])}));const r=l.get(t),i=r[c].findIndex((e=>e[d]===s));r[c][i]=o,l.set(t,r),l.set(s,o)}static deleteNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:c,hasChildren:s}=n,o=a[d];if(l.has(o)){const e=l.get(t),a=e[c];a.splice(a.findIndex((e=>e[d]===o)),1),e[s]=a.length,e[s]||(e.isLeaf=!0,e.expanded=!1),l.set(t,e),l.delete(o)}}}}}]);