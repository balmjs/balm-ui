"use strict";(self.webpackChunkbalm_ui=self.webpackChunkbalm_ui||[]).push([[6758],{66758:function(e,t,a){a.d(t,{A:function(){return p}});var n=a(35720),l=a(59891),d=a(58511),s=a(38796);const c={key:0,class:"mdc-tree-node__indent"},r={class:"mdc-tree-node__icon"},i=["onClick"],o=["onClick"],h=["onClick"],u={name:"UiTreeNode",customOptions:{UI_GLOBAL:s.A}};var p=Object.assign(u,{props:{children:{type:Array,default:()=>[]},treeData:{type:Object,default:()=>({})}},setup(e){const t=e,a=t.treeData.dataFormat;function u(e){!e.disabled&&l.Z.onCheck(t.treeData,e)}function p(e){const{children:t,...n}=e;return e[a.isLeaf]?e:n}return(k,m)=>{const f=(0,n.resolveComponent)("ui-tree-node");return(0,n.openBlock)(),(0,n.createElementBlock)("ul",null,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(e.children,((m,y)=>((0,n.openBlock)(),(0,n.createElementBlock)("li",{key:y,class:(0,n.normalizeClass)(["mdc-tree-node",{"mdc-tree-node--root":m.isRoot,"mdc-tree-node--leaf":m.isLeaf}])},[(0,n.createElementVNode)("div",{class:(0,n.normalizeClass)(["mdc-tree-node__content",{"mdc-tree-node--selected":m.selected||m.checked}])},[(0,n.renderSlot)(k.$slots,"before",{data:p(m)}),m.level?((0,n.openBlock)(),(0,n.createElementBlock)("div",c,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(m.level,(e=>((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:e,class:"mdc-tree-node__indent-unit"})))),128))])):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("div",r,[m[(0,n.unref)(a).isLeaf]?(0,n.createCommentVNode)("",!0):((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:0,onClick:e=>{return a=m,void l.Z.onExpand(t.treeData,a);var a}},[m.expanded?(0,n.renderSlot)(k.$slots,"expand-more-icon",{key:0},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(s.A).cssClasses.icon),"aria-hidden":"true"}," expand_more ",2)])):(0,n.renderSlot)(k.$slots,"expand-less-icon",{key:1},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(s.A).cssClasses.icon),"aria-hidden":"true"}," chevron_right ",2)]))],8,i))]),e.treeData.multiple?((0,n.openBlock)(),(0,n.createElementBlock)("div",{key:1,class:"mdc-tree-node__checkbox",onClick:e=>u(m)},[m[(0,n.unref)(a).isLeaf]?((0,n.openBlock)(),(0,n.createBlock)(d.A,{key:0,checked:m.checked,disabled:m.disabled},null,8,["checked","disabled"])):((0,n.openBlock)(),(0,n.createBlock)(d.A,{key:1,checked:m.checked,indeterminate:m.indeterminate,disabled:m.disabled},null,8,["checked","indeterminate","disabled"]))],8,o)):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("label",{class:(0,n.normalizeClass)(["mdc-tree-node__label",{"mdc-tree-node__label--disabled":m.disabled}]),onClick:(0,n.withModifiers)((a=>{return e.treeData.multiple?u(m):void(!(n=m).disabled&&l.Z.onSelect(t.treeData,n));var n}),["prevent"])},[(0,n.renderSlot)(k.$slots,"title",{data:p(m)},(()=>[(0,n.createTextVNode)((0,n.toDisplayString)(m[(0,n.unref)(a).label]),1)]))],10,h),(0,n.renderSlot)(k.$slots,"after",{data:p(m)})],2),!m[(0,n.unref)(a).isLeaf]&&m.expanded?((0,n.openBlock)(),(0,n.createBlock)(f,{key:0,class:"mdc-tree-node__children",children:m[(0,n.unref)(a).children],"tree-data":e.treeData},(0,n.createSlots)({_:2},[(0,n.renderList)(k.$slots,((e,t)=>({name:t,fn:(0,n.withCtx)((e=>[(0,n.renderSlot)(k.$slots,t,(0,n.normalizeProps)((0,n.guardReactiveProps)(e)))]))})))]),1032,["children","tree-data"])):(0,n.createCommentVNode)("",!0)],2)))),128))])}}})},59891:function(e,t,a){a.d(t,{Z:function(){return s}});const n=(e,t,a)=>{let{selectedValue:n,nodeMap:l,dataFormat:d}=e,{level:s,parentKey:c}=a,r=Object.assign({},t);const{value:i,children:o,hasChildren:h,isLeaf:u,disabled:p}=d,k=r[i],m=Array.isArray(r[o])?r[o]:[],f=((e,t,a)=>e[t]||!a)(r,u,r[h]||m.length);return r.level=s,r.isRoot=!s,r.isLeaf=f,r.expanded=!1,r.selected=!Array.isArray(n)&&k===n,r.checked=Array.isArray(n)&&n.includes(k),r.parentKey=c,r.disabled=r[p],m.length||(r[o]=[]),f||(r.indeterminate=!1),l.has(k)||l.set(k,r),r};let l=[],d=[];class s{constructor(e){this.treeData=e}getData(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";const{dataFormat:l,maxLevel:d}=this.treeData,s=[],{value:c,children:r,hasChildren:i}=l;for(let o=0,h=e.length;o<h;o++){let l=n(this.treeData,e[o],{level:t,parentKey:a});const h=Array.isArray(l[r])?l[r]:[],u=l[i]||h.length;t<d&&u&&(l[r]=this.getData(h,t+1,l[c])),s.push(l)}return s}static addData(e,t,a){const{dataFormat:l,nodeMap:d}=e,s=[],{value:c,children:r}=l,i=t.level+1,o=t[c];for(let h=0,u=a.length;h<u;h++){let t=n(e,a[h],{level:i,parentKey:o});t.checked&&this.setMultipleSelectedValue(e,t[c],!0),s.push(t)}t[r]=s,t.expanded=!0,d.set(o,t)}static async onExpand(e,t){if(e.loadData){const{dataFormat:a}=e;if(t[a.children]&&t[a.children].length)t.expanded=!t.expanded;else{const n=await e.loadData(t[a.value],t);if(Array.isArray(n)){this.addData(e,t,n);const l=n.every((t=>e.selectedValue.includes(t[a.value])));if(!!l||n.some((t=>e.selectedValue.includes(t[a.value]))))if(l||1===n.length){const l=n[0][a.parentKey];l?(e.selectedValue.push(l),t.checked=!0):console.warn("[UiTree]","Missing `parentKey`")}else t.indeterminate=!0}else console.warn("[UiTree]","Invalid data")}}else t.expanded=!t.expanded}static async collapseAllNode(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);d.expanded=!1,d.children&&d.children.length&&this.collapseAllNode(e,d.children)}return!0}static setSingleSelectedValue(e,t,a){const{nodeMap:n}=e,l=n.get(t);l&&(l.selected=a,e.selectedEvent={selected:a,selectedNodes:t,node:l})}static onSelect(e,t){const{dataFormat:a,selectedValue:n}=e,l=t[a.value];n&&this.setSingleSelectedValue(e,n,!1),e.selectedValue=l,this.setSingleSelectedValue(e,l,!0)}static setMultipleSelectedValue(e,t,a){const{dataFormat:n,nodeMap:l,filterParentNode:d}=e,s=l.get(t);a&&!s.indeterminate?e.selectedValue.includes(t)||(d?s.isLeaf&&e.selectedValue.push(t):e.selectedValue.push(t)):e.selectedValue=e.selectedValue.filter((e=>e!==t))}static setChildrenCheckedValue(e,t,a){const{dataFormat:n,nodeMap:d}=e,{value:s,children:c}=n;for(let r=0,i=t.length;r<i;r++){let n=Object.assign({},t[r]);const i=n[s],o=n[c],h=d.get(i);h&&(a?!h.checked&&l.push(i):h.checked&&l.push(i),h.indeterminate=!1,h.checked=a,this.setMultipleSelectedValue(e,i,a)),!n.isLeaf&&o.length&&this.setChildrenCheckedValue(e,o,a)}}static setParentCheckedValue(e,t){const{dataFormat:a,nodeMap:n}=e,{value:d,children:s}=a;if(t){const a=t[d],c=t[s],r=c.filter((e=>e.checked||e.indeterminate)),i=n.get(a);if(r.length){const t=r.filter((e=>e.checked)).length,n=t===c.length;n?!i.checked&&l.push(a):i.checked&&l.push(a),i.checked=n,i.indeterminate=!n,this.setMultipleSelectedValue(e,a,n)}else i.checked=!1,i.indeterminate=!1,this.setMultipleSelectedValue(e,a,i.checked);t.isRoot||this.setParentCheckedValue(e,n.get(t.parentKey))}}static onCheck(e,t){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=!t.checked;"boolean"===typeof a&&(n=a);const{dataFormat:d,nodeMap:s,singleChecked:c}=e,{value:r,children:i}=d,o=t[r],h=t[i];c?(t.checked=n,this.setMultipleSelectedValue(e,o,n),e.selectedEvent={checked:n,checkedNodes:[o],node:t}):(l=[o],t.isLeaf?(t.checked=n,this.setMultipleSelectedValue(e,o,n)):(t.indeterminate&&(t.indeterminate=!1,n=!0),t.checked=n,this.setMultipleSelectedValue(e,o,n),this.setChildrenCheckedValue(e,h,n)),t.isRoot||this.setParentCheckedValue(e,s.get(t.parentKey)),e.selectedEvent={checked:n,checkedNodes:l,node:t})}static async handleExpandKeys(e,t,a){const{dataFormat:n,nodeMap:l}=e;for await(let d of t){const t=d[n.value],s=l.get(t);a.includes(t)&&this.onExpand(e,s),d.children&&d.children.length&&this.handleExpandKeys(e,d.children,a)}}static async handleExpandAll(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);this.onExpand(e,d),d.children&&d.children.length&&this.handleExpandAll(e,d.children)}}static async findTreeNode(e,t,a){if(e[t]===a)return e;if(e.children&&e.children.length)for(let n=0;n<e.children.length;n++){const l=await this.findTreeNode(e.children[n],t,a);if(null!==l)return l}return null}static toReverseArray(e){const t=[];for(let a=e.length-1;a>=0;a--)t.push(e[a]);return t}static async handleAutoExpandSelected(e,t,a,n){if(await this.collapseAllNode(n,e)){const l=await this.findTreeNode(e[0],t,a);if(d.push(l[t]),l.parentKey&&this.handleAutoExpandSelected(e,t,l.parentKey,n),!l.parentKey){const t=this.toReverseArray(d);n&&this.handleExpandKeys(n,e,t)}}}static async setExpanded(e,t,a){let{autoExpandParent:n,defaultExpandedKeys:l,autoExpandAll:d}=a;const{dataFormat:s,nodeMap:c}=e;if(d&&this.handleExpandAll(e,t),n)if(l.length)this.handleExpandKeys(e,t,l);else for await(let r of t){const t=r[s.value],a=c.get(t);this.onExpand(e,a)}}static resetSelected(e,t){const{nodeMap:a}=e;for(let n=0,l=t.length;n<l;n++){const l=t[n],d=a.get(l);d&&this.onCheck(e,d,!1)}}static setSelected(e,t,a){let{nodeList:n,autoExpandSelected:l}=a;const{dataFormat:s,nodeMap:c,multiple:r}=e,i=Array.isArray(t)?t:[t];for(let d=0,o=i.length;d<o;d++){const t=i[d],a=c.get(t);a&&(r?this.onCheck(e,a,!0):this.onSelect(e,a))}l&&!Array.isArray(t)&&(d=[],this.handleAutoExpandSelected(n,s.value,t,e))}static async createNode(e,t,a){const{dataFormat:l,nodeMap:d}=e,{value:s,children:c,hasChildren:r}=l,i=d.get(t),o=a[s];let h=n(e,a,{level:i.level+1,parentKey:t,checked:!1});i.isLeaf?(i[c].unshift(h),i[r]||(i[r]=!0),i.isLeaf=!1):i[r]?i[c].length?i[c].unshift(h):await this.onExpand(e,i):(i[c].unshift(h),i[r]=!0,i.expanded=!0),d.set(t,i),d.set(o,h)}static updateNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:s}=n,c=a[d],r=l.get(c);Object.keys(r).forEach((e=>{"undefined"!==typeof a[e]&&(r[e]=a[e])}));const i=l.get(t),o=i[s].findIndex((e=>e[d]===c));i[s][o]=r,l.set(t,i),l.set(c,r)}static deleteNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:s,hasChildren:c}=n,r=a[d];if(l.has(r)){const e=l.get(t),a=e[s];a.splice(a.findIndex((e=>e[d]===r)),1),e[c]=a.length,e[c]||(e.isLeaf=!0,e.expanded=!1),l.set(t,e),l.delete(r)}}}}}]);