"use strict";(self.webpackChunkbalm_ui=self.webpackChunkbalm_ui||[]).push([[5349],{55415:function(e,t,a){a.d(t,{Z:function(){return p}});var n=a(73114),l=a(76580),d=a(22782),c=a(5522);const s={key:0,class:"mdc-tree-node__indent"},r={class:"mdc-tree-node__icon"},o=["onClick"],i=["onClick"],h=["onClick"],u={name:"UiTreeNode",customOptions:{UI_GLOBAL:c.Z}};var p=Object.assign(u,{props:{children:{type:Array,default:()=>[]},treeData:{type:Object,default:()=>({})}},setup(e){const t=e,a=t.treeData.dataFormat;function u(e){e.disabled||l.w.onCheck(t.treeData,e)}function p(e){const{children:t,...n}=e;return e[a.isLeaf]?e:n}return(k,m)=>{const f=(0,n.resolveComponent)("ui-tree-node");return(0,n.openBlock)(),(0,n.createElementBlock)("ul",null,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(e.children,((m,y)=>((0,n.openBlock)(),(0,n.createElementBlock)("li",{key:y,class:(0,n.normalizeClass)(["mdc-tree-node",{"mdc-tree-node--root":m.isRoot,"mdc-tree-node--leaf":m.isLeaf}])},[(0,n.createElementVNode)("div",{class:(0,n.normalizeClass)(["mdc-tree-node__content",{"mdc-tree-node--selected":m.selected||m.checked}])},[(0,n.renderSlot)(k.$slots,"before",{data:p(m)}),m.level?((0,n.openBlock)(),(0,n.createElementBlock)("div",s,[((0,n.openBlock)(!0),(0,n.createElementBlock)(n.Fragment,null,(0,n.renderList)(m.level,(e=>((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:e,class:"mdc-tree-node__indent-unit"})))),128))])):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("div",r,[m[(0,n.unref)(a).isLeaf]?(0,n.createCommentVNode)("",!0):((0,n.openBlock)(),(0,n.createElementBlock)("span",{key:0,onClick:e=>{return a=m,void l.w.onExpand(t.treeData,a);var a}},[m.expanded?(0,n.renderSlot)(k.$slots,"expand-more-icon",{key:0},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(c.Z).cssClasses.icon),"aria-hidden":"true"}," expand_more ",2)])):(0,n.renderSlot)(k.$slots,"expand-less-icon",{key:1},(()=>[(0,n.createElementVNode)("i",{class:(0,n.normalizeClass)((0,n.unref)(c.Z).cssClasses.icon),"aria-hidden":"true"}," chevron_right ",2)]))],8,o))]),e.treeData.multiple?((0,n.openBlock)(),(0,n.createElementBlock)("div",{key:1,class:"mdc-tree-node__checkbox",onClick:e=>u(m)},[m[(0,n.unref)(a).isLeaf]?((0,n.openBlock)(),(0,n.createBlock)(d.Z,{key:0,checked:m.checked,disabled:m.disabled},null,8,["checked","disabled"])):((0,n.openBlock)(),(0,n.createBlock)(d.Z,{key:1,checked:m.checked,indeterminate:m.indeterminate,disabled:m.disabled},null,8,["checked","indeterminate","disabled"]))],8,i)):(0,n.createCommentVNode)("",!0),(0,n.createElementVNode)("label",{class:"mdc-tree-node__label",onClick:(0,n.withModifiers)((a=>{return e.treeData.multiple?u(m):void((n=m).disabled||l.w.onSelect(t.treeData,n));var n}),["prevent"])},[(0,n.renderSlot)(k.$slots,"title",{data:p(m)},(()=>[(0,n.createTextVNode)((0,n.toDisplayString)(m[(0,n.unref)(a).label]),1)]))],8,h),(0,n.renderSlot)(k.$slots,"after",{data:p(m)})],2),!m[(0,n.unref)(a).isLeaf]&&m.expanded?((0,n.openBlock)(),(0,n.createBlock)(f,{key:0,class:"mdc-tree-node__children",children:m[(0,n.unref)(a).children],"tree-data":e.treeData},(0,n.createSlots)({_:2},[(0,n.renderList)(k.$slots,((e,t)=>({name:t,fn:(0,n.withCtx)((e=>[(0,n.renderSlot)(k.$slots,t,(0,n.normalizeProps)((0,n.guardReactiveProps)(e)))]))})))]),1032,["children","tree-data"])):(0,n.createCommentVNode)("",!0)],2)))),128))])}}})},76580:function(e,t,a){a.d(t,{w:function(){return c}});const n=(e,t,a)=>{let{selectedValue:n,nodeMap:l,dataFormat:d}=e,{level:c,parentKey:s}=a,r=Object.assign({},t);const{value:o,children:i,hasChildren:h,isLeaf:u,disabled:p}=d,k=r[o],m=Array.isArray(r[i])?r[i]:[],f=((e,t,a)=>e[t]||!a)(r,u,r[h]||m.length);return r.level=c,r.isRoot=!c,r.isLeaf=f,r.expanded=!1,r.selected=!Array.isArray(n)&&k===n,r.checked=Array.isArray(n)&&n.includes(k),r.parentKey=s,r.disabled=r[p],m.length||(r[i]=[]),f||(r.indeterminate=!1),l.has(k)||l.set(k,r),r};let l=[],d=[];class c{constructor(e){this.treeData=e}getData(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";const{dataFormat:l,maxLevel:d}=this.treeData,c=[],{value:s,children:r,hasChildren:o}=l;for(let i=0,h=e.length;i<h;i++){let l=n(this.treeData,e[i],{level:t,parentKey:a});const h=Array.isArray(l[r])?l[r]:[],u=l[o]||h.length;t<d&&u&&(l[r]=this.getData(h,t+1,l[s])),c.push(l)}return c}static addData(e,t,a){const{dataFormat:l,nodeMap:d}=e,c=[],{value:s,children:r}=l,o=t.level+1,i=t[s];for(let h=0,u=a.length;h<u;h++){let t=n(e,a[h],{level:o,parentKey:i});t.checked&&this.setMultipleSelectedValue(e,t[s],!0),c.push(t)}t[r]=c,t.expanded=!0,d.set(i,t)}static async onExpand(e,t){if(e.loadData){const{dataFormat:a}=e;if(t[a.children]&&t[a.children].length)t.expanded=!t.expanded;else{let n=await e.loadData(t[a.value],t);Array.isArray(n)?this.addData(e,t,n):console.warn("[UiTree]","Invalid data")}}else t.expanded=!t.expanded}static async collapseAllNode(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);d.expanded=!1,d.children&&d.children.length&&this.collapseAllNode(e,d.children)}return!0}static setSingleSelectedValue(e,t,a){const{nodeMap:n}=e,l=n.get(t);l&&(l.selected=a,e.selectedEvent={selected:a,selectedNodes:t,node:l})}static onSelect(e,t){const{dataFormat:a,selectedValue:n}=e,l=t[a.value];n&&this.setSingleSelectedValue(e,n,!1),e.selectedValue=l,this.setSingleSelectedValue(e,l,!0)}static setMultipleSelectedValue(e,t,a){const{dataFormat:n,nodeMap:l,filterParentNode:d}=e,c=l.get(t);a&&!c.indeterminate?e.selectedValue.includes(t)||(d?c.isLeaf&&e.selectedValue.push(t):e.selectedValue.push(t)):e.selectedValue=e.selectedValue.filter((e=>e!==t))}static setChildrenCheckedValue(e,t,a){const{dataFormat:n,nodeMap:d}=e,{value:c,children:s}=n;for(let r=0,o=t.length;r<o;r++){let n=Object.assign({},t[r]);const o=n[c],i=n[s],h=d.get(o);h&&(a?!h.checked&&l.push(o):h.checked&&l.push(o),h.indeterminate=!1,h.checked=a,this.setMultipleSelectedValue(e,o,a)),!n.isLeaf&&i.length&&this.setChildrenCheckedValue(e,i,a)}}static setParentCheckedValue(e,t){const{dataFormat:a,nodeMap:n}=e,{value:d,children:c}=a;if(t){const a=t[d],s=t[c],r=s.filter((e=>e.checked||e.indeterminate)),o=n.get(a);if(r.length){const t=r.filter((e=>e.checked)).length,n=t===s.length;n?!o.checked&&l.push(a):o.checked&&l.push(a),o.checked=n,o.indeterminate=!n,this.setMultipleSelectedValue(e,a,n)}else o.checked=!1,o.indeterminate=!1;t.isRoot||this.setParentCheckedValue(e,n.get(t.parentKey))}}static onCheck(e,t){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=!t.checked;"boolean"===typeof a&&(n=a);const{dataFormat:d,nodeMap:c,singleChecked:s}=e,{value:r,children:o}=d,i=t[r],h=t[o];s?(t.checked=n,this.setMultipleSelectedValue(e,i,n),e.selectedEvent={checked:n,checkedNodes:[i],node:t}):(l=[i],t.isLeaf?(t.checked=n,this.setMultipleSelectedValue(e,i,n)):(t.indeterminate&&(t.indeterminate=!1,n=!0),t.checked=n,this.setMultipleSelectedValue(e,i,n),this.setChildrenCheckedValue(e,h,n)),t.isRoot||this.setParentCheckedValue(e,c.get(t.parentKey)),e.selectedEvent={checked:n,checkedNodes:l,node:t})}static async handleExpandKeys(e,t,a){const{dataFormat:n,nodeMap:l}=e;for await(let d of t){const t=d[n.value],c=l.get(t);a.includes(t)&&this.onExpand(e,c),d.children&&d.children.length&&this.handleExpandKeys(e,d.children,a)}}static async handleExpandAll(e,t){const{dataFormat:a,nodeMap:n}=e;for await(let l of t){const t=l[a.value],d=n.get(t);this.onExpand(e,d),d.children&&d.children.length&&this.handleExpandAll(e,d.children)}}static async findTreeNode(e,t,a){if(e[t]===a)return e;if(e.children&&e.children.length)for(let n=0;n<e.children.length;n++){const l=await this.findTreeNode(e.children[n],t,a);if(null!==l)return l}return null}static toReverseArray(e){const t=[];for(let a=e.length-1;a>=0;a--)t.push(e[a]);return t}static async handleAutoExpandSelected(e,t,a,n){if(await this.collapseAllNode(n,e)){const l=await this.findTreeNode(e[0],t,a);if(d.push(l[t]),l.parentKey&&this.handleAutoExpandSelected(e,t,l.parentKey,n),!l.parentKey){const t=this.toReverseArray(d);n&&this.handleExpandKeys(n,e,t)}}}static async setExpanded(e,t,a){let{autoExpandParent:n,defaultExpandedKeys:l,autoExpandAll:d}=a;const{dataFormat:c,nodeMap:s}=e;if(d&&this.handleExpandAll(e,t),n)if(l.length)this.handleExpandKeys(e,t,l);else for await(let r of t){const t=r[c.value],a=s.get(t);this.onExpand(e,a)}}static resetSelected(e,t){const{nodeMap:a}=e;for(let n=0,l=t.length;n<l;n++){const l=t[n],d=a.get(l);d&&this.onCheck(e,d,!1)}}static setSelected(e,t,a){let{nodeList:n,autoExpandSelected:l}=a;const{dataFormat:c,nodeMap:s,multiple:r}=e,o=Array.isArray(t)?t:[t];for(let d=0,i=o.length;d<i;d++){const t=o[d],a=s.get(t);a&&(r?this.onCheck(e,a,!0):this.onSelect(e,a))}l&&!Array.isArray(t)&&(d=[],this.handleAutoExpandSelected(n,c.value,t,e))}static async createNode(e,t,a){const{dataFormat:l,nodeMap:d}=e,{value:c,children:s,hasChildren:r}=l,o=d.get(t),i=a[c];let h=n(e,a,{level:o.level+1,parentKey:t,checked:!1});o.isLeaf?(o[s].unshift(h),o[r]||(o[r]=!0),o.isLeaf=!1):o[r]?o[s].length?o[s].unshift(h):await this.onExpand(e,o):(o[s].unshift(h),o[r]=!0,o.expanded=!0),d.set(t,o),d.set(i,h)}static updateNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:c}=n,s=a[d],r=l.get(s);Object.keys(r).forEach((e=>{"undefined"!==typeof a[e]&&(r[e]=a[e])}));const o=l.get(t),i=o[c].findIndex((e=>e[d]===s));o[c][i]=r,l.set(t,o),l.set(s,r)}static deleteNode(e,t,a){const{dataFormat:n,nodeMap:l}=e,{value:d,children:c,hasChildren:s}=n,r=a[d];if(l.has(r)){const e=l.get(t),a=e[c];a.splice(a.findIndex((e=>e[d]===r)),1),e[s]=a.length,e[s]||(e.isLeaf=!0,e.expanded=!1),l.set(t,e),l.delete(r)}}}}}]);