<template>
  <!-- Container -->
  <div :class="className">
    <template v-if="hasFixedCell">
      <mdc-table-frame
        class="mdc-data-table__fixed-header"
        :columns-data="columns.data"
        :offset-left="offsetLeft"
      >
        <mdc-table-header
          :selected-rows="selectedRows"
          :thead="thead"
          :row-checkbox="rowCheckbox"
          :sort-icon-align-end="sortIconAlignEnd"
          :fixed="hasFixedCell"
          :cell-style="cellStyle"
          :fixed-scroll-width="fixedScrollWidth"
        >
          <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
          <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
            <slot :name="name" v-bind="slotData"></slot>
          </template>
        </mdc-table-header>
      </mdc-table-frame>
      <mdc-table-frame
        ref="content"
        class="mdc-data-table__fixed-body"
        :columns-data="columns.data"
        :scroll="scroll"
        :max-width="maxWidth"
      >
        <mdc-table-body
          :data="data"
          :current-data="currentData"
          :selected-rows="selectedRows"
          :tbody="tbody"
          :row-checkbox="rowCheckbox"
          :row-checkbox-disabled="rowCheckboxDisabled"
          :selected-key="selectedKey"
          :row-id-prefix="rowIdPrefix"
          :cell-style="cellStyle"
        >
          <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
          <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
            <slot :name="name" v-bind="slotData"></slot>
          </template>
        </mdc-table-body>
      </mdc-table-frame>
      <mdc-table-frame
        class="mdc-data-table__fixed-footer"
        :columns-data="columns.data"
        :offset-left="offsetLeft"
      >
        <mdc-table-footer
          :data="data"
          :tfoot="tfoot"
          :row-checkbox="rowCheckbox"
          :columns="columns.count"
          :cell-style="cellStyle"
        >
          <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
          <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
            <slot :name="name" v-bind="slotData"></slot>
          </template>
        </mdc-table-footer>
      </mdc-table-frame>
    </template>
    <mdc-table-frame v-else :columns-data="columns.data">
      <mdc-table-header
        :selected-rows="selectedRows"
        :thead="thead"
        :row-checkbox="rowCheckbox"
        :sort-icon-align-end="sortIconAlignEnd"
      >
        <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
        <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
          <slot :name="name" v-bind="slotData"></slot>
        </template>
      </mdc-table-header>
      <mdc-table-body
        :data="data"
        :current-data="currentData"
        :selected-rows="selectedRows"
        :tbody="tbody"
        :row-checkbox="rowCheckbox"
        :row-checkbox-disabled="rowCheckboxDisabled"
        :selected-key="selectedKey"
        :row-id-prefix="rowIdPrefix"
      >
        <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
        <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
          <slot :name="name" v-bind="slotData"></slot>
        </template>
      </mdc-table-body>
      <mdc-table-footer
        :data="data"
        :tfoot="tfoot"
        :row-checkbox="rowCheckbox"
        :columns="columns.count"
      >
        <slot v-for="(_, name) in $slots" :slot="name" :name="name"></slot>
        <template v-for="(_, name) in $scopedSlots" v-slot:[name]="slotData">
          <slot :name="name" v-bind="slotData"></slot>
        </template>
      </mdc-table-footer>
    </mdc-table-frame>

    <mdc-table-progress></mdc-table-progress>

    <slot></slot>
  </div>
</template>

<script>
import { MDCDataTable } from '../../../material-components-web/data-table';
import { events } from '../../../material-components-web/data-table/constants';
import MdcTableFrame from './mdc-table-frame.vue';
import MdcTableHeader from './mdc-table-header.vue';
import MdcTableBody from './mdc-table-body.vue';
import MdcTableFooter from './mdc-table-footer.vue';
import MdcTableProgress from './mdc-table-progress.vue';
import UI_TABLE from './constants';
import getType from '../../utils/typeof';

export default {
  name: 'UiTable',
  components: {
    MdcTableFrame,
    MdcTableHeader,
    MdcTableBody,
    MdcTableFooter,
    MdcTableProgress
  },
  model: {
    prop: 'selectedRows',
    event: UI_TABLE.EVENT.SELECTED
  },
  props: {
    // States
    data: {
      type: Array,
      default() {
        return [];
      }
    },
    selectedRows: {
      type: Array,
      default() {
        return [];
      }
    },
    // UI attributes
    thead: {
      type: Array,
      default() {
        return [];
      }
    },
    tbody: {
      type: Array,
      default() {
        return [];
      }
    },
    tfoot: {
      type: Array,
      default() {
        return [];
      }
    },
    fullwidth: {
      type: Boolean,
      default: false
    },
    rowCheckbox: {
      type: Boolean,
      default: false
    },
    rowCheckboxDisabled: {
      type: [Function, Boolean],
      default: false
    },
    selectedKey: {
      type: [Boolean, String],
      default: false
    },
    rowIdPrefix: {
      type: String,
      default: ''
    },
    sortIconAlignEnd: {
      type: Boolean,
      default: false
    },
    showProgress: {
      type: Boolean,
      default: false
    },
    fixedHeader: {
      type: Boolean,
      default: false
    },
    defaultColWidth: {
      type: Number,
      default: 0
    },
    scroll: {
      type: Object,
      default() {
        return {
          x: false,
          y: false
        };
      }
    }
  },
  data() {
    return {
      UI_TABLE,
      $table: null,
      columnsData: this.tbody,
      currentData: this.data,
      ticking: false,
      offsetLeft: 0,
      maxWidth: 0,
      fixedScrollWidth: 0
    };
  },
  computed: {
    className() {
      return {
        'mdc-data-table': true,
        'mdc-data-table--fixed': this.hasFixedCell,
        'mdc-data-table--fullwidth': this.fullwidth
      };
    },
    hasFixedCell() {
      const fixedFirstColumn =
        getType(this.tbody[0]) === 'object' ? this.tbody[0].fixed : false;
      const fixedLastColumn =
        getType(this.tbody[this.tbody.length - 1]) === 'object'
          ? this.tbody[this.tbody.length - 1].fixed
          : false;

      const hasFixedColumn = !!(
        this.fixedHeader ||
        fixedFirstColumn ||
        fixedLastColumn
      );

      if (hasFixedColumn && !this.defaultColWidth) {
        console.warn('[UiTable]', 'You need set defaultColWidth prop first');
      }

      return this.defaultColWidth && hasFixedColumn;
    },
    columns() {
      let count = this.columnsData.length;
      let maxWidth = 0;
      let data = this.tbody.map(({ colClass, width }) => {
        const colWidth = width || this.defaultColWidth;
        maxWidth += colWidth;

        return {
          class: colClass,
          style: colWidth ? { width: `${colWidth}px` } : null
        };
      });

      if (this.rowCheckbox) {
        count += 1;
        maxWidth += UI_TABLE.CHECKBOX_COL_WIDTH;
        data.unshift({
          class: 'checkbox',
          style: { width: `${UI_TABLE.CHECKBOX_COL_WIDTH}px` }
        });
      }

      this.$nextTick(() => {
        const currentWidth = this.$el.offsetWidth;
        if (this.hasFixedCell && currentWidth > maxWidth) {
          console.warn(
            '[UiTable]',
            `The table max width is ${maxWidth}px, but the current is ${currentWidth}px.`
          );
        }
      });

      return {
        count,
        data
      };
    },
    cellStyle() {
      let result = [];

      let originTbody = Object.assign([], this.tbody);
      if (this.rowCheckbox) {
        originTbody.unshift(
          this.hasFixedCell
            ? {
                fixed: 'left',
                width: UI_TABLE.CHECKBOX_COL_WIDTH
              }
            : {}
        );
      }

      let sumWidth = 0;
      for (let index = 0, len = originTbody.length; index < len; index++) {
        let style;

        let { fixed } = originTbody[index];
        let fixedWidth = 0;
        switch (fixed) {
          case 'left':
            if (index > 0) {
              let { width } = originTbody[index - 1];
              sumWidth += width;
              fixedWidth = `${sumWidth}px`;
            }
            style = { position: 'sticky', left: fixedWidth };
            break;
          case 'right':
            if (index < len - 1) {
              sumWidth = 0;
              for (let j = index + 1; j < len; j++) {
                let { width } = originTbody[j];
                sumWidth += width;
              }
              fixedWidth = `${sumWidth}px`;
            }
            style = { position: 'sticky', right: fixedWidth };
            break;
          default:
        }

        result.push(style);
      }

      return result;
    }
  },
  watch: {
    data(val) {
      this.currentData = val;

      this.$nextTick(() => {
        this.$table.hideProgress();
        this.$table.layout();
        this.initSelectedRows();

        if (this.$refs.content) {
          this.fixedScrollWidth =
            this.$refs.content.$el.offsetWidth -
            this.$refs.content.$el.clientWidth;
        }
      });
    },
    showProgress(val) {
      if (val) {
        this.$table.showProgress();
      } else {
        this.$table.hideProgress();
      }
    }
  },
  mounted() {
    this.$table = new MDCDataTable(this.$el);

    this.$table.listen(events.ROW_SELECTION_CHANGED, ({ detail }) => {
      let selectedRows = this.selectedRows; // NOTE: cache selected rows for pagination

      this.currentData.forEach((tbodyRowData, tbodyRowIndex) => {
        let selectedRowId = this.selectedKey
          ? tbodyRowData[this.selectedKey]
          : tbodyRowIndex;

        if (tbodyRowIndex === detail.rowIndex) {
          // checked
          if (detail.selected) {
            selectedRows.push(selectedRowId);
          } else {
            // unchecked
            selectedRows.splice(
              selectedRows.findIndex(
                (selectedKey) => selectedKey === selectedRowId
              ),
              1
            );
          }
        }
      });

      this.$emit(UI_TABLE.EVENT.SELECTED, selectedRows);
    });

    this.$table.listen(events.SELECTED_ALL, () => {
      let oldSelectedRows = this.selectedRows; // NOTE: cache selected rows for pagination

      let disabledSelectedRows = [];
      let newSelectedRows = this.currentData.map(
        (tbodyRowData, tbodyRowIndex) => {
          const currentRowData = this.selectedKey
            ? tbodyRowData[this.selectedKey]
            : tbodyRowIndex;

          const disabledRowData =
            this.selectedKey &&
            getType(this.rowCheckboxDisabled) === 'function' &&
            this.rowCheckboxDisabled({
              [this.selectedKey]: currentRowData
            });

          if (disabledRowData) {
            disabledSelectedRows.push(currentRowData);
          }

          return currentRowData;
        }
      );

      const unionSelectedRows = Array.from(
        new Set([...oldSelectedRows, ...newSelectedRows])
      );
      const disabledSelectedRowsSet = new Set(disabledSelectedRows);

      const selectedRows = unionSelectedRows.filter(
        (selectedRow) => !disabledSelectedRowsSet.has(selectedRow)
      );

      this.$emit(UI_TABLE.EVENT.SELECTED, selectedRows);
    });

    this.$table.listen(events.UNSELECTED_ALL, () => {
      let oldSelectedRows = this.selectedRows; // NOTE: cache selected rows for pagination

      let newSelectedRows = this.currentData.map(
        (tbodyRowData, tbodyRowIndex) => {
          return this.selectedKey
            ? tbodyRowData[this.selectedKey]
            : tbodyRowIndex;
        }
      );

      // Difference set
      let a = new Set(oldSelectedRows);
      let b = new Set(newSelectedRows);
      let selectedRows = Array.from(new Set([...a].filter((x) => !b.has(x))));

      this.$emit(UI_TABLE.EVENT.SELECTED, selectedRows);
    });

    this.$table.listen(events.SORTED, ({ detail }) => {
      // TODO: multi-row header is unsupported
      this.handleSort(detail);

      this.$emit(UI_TABLE.EVENT.SORTED, detail);
    });

    if (this.selectedRows.length) {
      this.initSelectedRows();
    }

    if (this.showProgress) {
      this.$table.showProgress();
    }

    if (this.hasFixedCell) {
      this.$refs.content.$el.addEventListener('scroll', this.handleScroll);

      if (this.rowCheckbox) {
        this.maxWidth += UI_TABLE.CHECKBOX_COL_WIDTH;
      }

      this.tbody.forEach(({ width }) => {
        this.maxWidth += width || this.defaultColWidth;
      });
    }
  },
  beforeDestroy() {
    if (this.hasFixedCell) {
      this.$refs.content.$el.removeEventListener('scroll', this.handleScroll);
    }
  },
  methods: {
    handleSort({ columnId, sortValue }) {
      let newSelectedRows = [];

      if (sortValue) {
        const isNumber = this.currentData.every(
          (tbodyRowData) => getType(tbodyRowData[columnId]) === 'number'
        );

        if (sortValue === 'descending') {
          this.currentData.sort(
            isNumber
              ? (a, b) => {
                  return b[columnId] - a[columnId];
                }
              : (a, b) => {
                  return b[columnId].localeCompare(a[columnId]);
                }
          );
        } else if (sortValue === 'ascending') {
          this.currentData.sort(
            isNumber
              ? (a, b) => {
                  return a[columnId] - b[columnId];
                }
              : (a, b) => {
                  return a[columnId].localeCompare(b[columnId]);
                }
          );
        }

        let oldSelectedRows = this.selectedRows;
        if (this.selectedKey) {
          newSelectedRows = [...oldSelectedRows];
        } else {
          const tableRowCount = this.currentData.length;

          let oldSelectedIndex = 0;
          for (let index = tableRowCount - 1; index >= 0; index--) {
            if (oldSelectedRows.includes(oldSelectedIndex)) {
              newSelectedRows.push(index);
            }
            oldSelectedIndex++;
          }
          newSelectedRows.sort();
        }
      }

      this.$emit(UI_TABLE.EVENT.SELECTED, newSelectedRows);
    },
    initSelectedRows() {
      if (this.rowCheckbox && this.currentData.length) {
        let rowIds = this.selectedRows
          .map((selectedRow) => {
            let rowIndex = this.selectedKey
              ? this.currentData.findIndex(
                  (tbodyRowData) =>
                    tbodyRowData[this.selectedKey] === selectedRow
                )
              : selectedRow;
            return `${this.rowIdPrefix}${rowIndex}`;
          })
          .filter((row) => ~row);

        this.$table.setSelectedRowIds(rowIds);
      }
    },
    handleScroll(e) {
      if (!this.ticking) {
        window.requestAnimationFrame(() => {
          const offsetLeft = e.target.scrollLeft;

          if (this.offsetLeft != offsetLeft) {
            this.offsetLeft = offsetLeft;
          }

          this.ticking = false;
        });
        this.ticking = true;
      }
    }
  }
};
</script>
